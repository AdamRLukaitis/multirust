#!/bin/sh

help() {
    echo "Usage: multirust <command> [--verbose] [--version]"
    echo
    echo "Commands:"
    echo
    echo "    default          Set the default toolchain"
    echo "    override         Set the toolchain override for the current directory tree"
    echo "    alias            Create alias commands for a toolchain"
    echo "    update           Update a given toolchain"
    echo "    show-default     Show information about the current default"
    echo "    show-override    Show information about the current override"
    echo "    list-overrides   List all overrides"
    echo "    list-toolchains  List all installed toolchains"
    echo "    remove-override  Remove the current override"
    echo "    remove-toolchain Uninstall a toolchain"
    echo "    remove-alias     Delete alias toolchain commands"
    echo "    delete-data      Delete all user metadata, including installed toolchains"
    echo "    upgrade-data     Upgrade user metadata from previous versions"
    echo "    gc               Delete unused toolchains"
    echo "    help             Show help for this command or subcommands"
    echo
    echo "Use \`multirust help <command>\` for detailed help."
}

help_default() {
    echo "Installs and configures the default toolchain."
    echo
    echo "Usage: multirust default <toolchain>"
}

help_override() {
    echo "Installs and configures a toolchain that will override the default"
    echo "when working at or below the current directory."
    echo
    echo "To remove an existing override use \`multirust remove-override\`."
    echo
    echo "Usage: multirust override <toolchain>"
}

help_update() {
    echo "Updates an installed toolchain or installs from scratch if it is"
    echo "not yet installed."
    echo
    echo "Usage: multirust update <toolchain>"
}

help_show_default() {
    echo "Displays information about the default toolchain."
    echo
    echo "Usage: multirust show-default"
}

help_show_override() {
    echo "Displays information about the current toolchain override."
    echo
    echo "Usage: multirust show-override"
}

help_list_overrides() {
    echo "Displays a list of all overrides."
    echo
    echo "Usage: multirust list-overrides"
}

help_list_toolchains() {
    echo "Displays a list of all toolchains."
    echo
    echo "Usage: multirust list-toolchains"
}

help_remove_override() {
    echo "Removes the override for the current directory."
    echo
    echo "Usage: multirust remove-override"
}

help_remove_toolchain() {
    echo "Uninstalls an installed toolchain."
    echo
    echo "Usage: multirust remove-toolchain <toolchain>"
}

help_delete_data() {
    echo "Deletes the ~/.multirust directory, removing all installed toolchains,"
    echo "overrides, and aliases for the current user."
    echo
    echo "Prompts for confirmation. Disable prompt with -y."
    echo
    echo "Does not delete global aliases."
    echo
    echo "Usage: multirust delete-data [-y]."
}

# Some utilities

say() {
    echo "multirust: $1"
}

verbose_say() {
    if [ "$flag_verbose" = true ]; then
	say "$1"
    fi
}

err() {
    say "$1" >&2
    exit 1
}

need_cmd() {
    if ! command -v $1 > /dev/null 2>&1
    then err "need $1"
    fi
}

need_ok() {
    if [ $? != 0 ]; then err "$1"; fi
}

assert_nz() {
    if [ -z "$1" ]; then err "assert_nz $2"; fi
}

# Ensure various commands exist
need_cmd dirname
need_cmd basename
need_cmd mkdir
need_cmd cat
need_cmd curl
need_cmd mktemp
need_cmd rm
need_cmd egrep
need_cmd grep
need_cmd file
need_cmd uname
need_cmd tar
need_cmd sed
need_cmd sh
need_cmd mv
need_cmd awk
need_cmd cut
need_cmd sort
need_cmd shasum
need_cmd date

# Environment sanity checks
assert_nz "$HOME" "\$HOME is undefined"
assert_nz "$0" "\$0 is undefined"

# Some constants
version=0.0.1
# This will be replaced by the build script
commit_version=
metadata_version=1
dist_server="${MULTIRUST_DIST_SERVER-https://static.rust-lang.org}"
rust_dist_dir=dist
default_spec=nightly
multirust_cmd="$0"
cmd_dirname="$(dirname "$0")"
cmd_basename="$(basename "$0")"
abs_cmd_basename="$(cd "$cmd_dirname" && pwd)"
home="${MULTIRUST_HOME-$HOME}"
multirust_dir="$home/.multirust"
version_file="$multirust_dir/version"
override_db="$multirust_dir/overrides"
default_file="$multirust_dir/default"
toolchains_dir="$multirust_dir/toolchains"
manifests_dir="$multirust_dir/manifests"
installer_dir="$multirust_dir/installers"
channel_sums_dir="$multirust_dir/channel-sums"
temp_dir="$multirust_dir/tmp"
update_stamp_file="$multirust_dir/update-stamp"
update_list_file="$multirust_dir/available-updates"
rust_package_name="rust"

# Some globals
flag_verbose=false
flag_yes=false

call_multirust() {
    assert_nz "$multirust_cmd" "multirust"
    "$multirust_cmd" "$@"
}

make_temp_name() {
    local _pid="$$"
    assert_nz "$_pid" "pid"

    local _tmp_number="${NEXT_TMP_NUMBER-0}"
    local _tmp_name="tmp-$_pid-$_tmp_number"
    NEXT_TMP_NUMBER="$(expr "$_tmp_number" + 1)"
    assert_nz "$NEXT_TMP_NUMBER" "NEXT_TMP_NUMBER"
    RETVAL="$_tmp_name"
}

make_temp() {
    mkdir -p "$temp_dir"
    need_ok "failed to make temp dir '$temp_dir'"

    make_temp_name
    local _tmp_name="$temp_dir/$RETVAL"
    touch "$_tmp_name"
    need_ok "couldn't make temp file '$_tmp_name'"
    RETVAL="$_tmp_name"
}

make_temp_dir() {
    mkdir -p "$temp_dir"
    need_ok "failed to make temp dir '$temp_dir'"

    make_temp_name
    local _tmp_name="$temp_dir/$RETVAL"
    mkdir -p "$_tmp_name"
    need_ok "couldn't make temp dir '$_tmp_name'"
    RETVAL="$_tmp_name"
}

# Returns 0 on success, like sha256sum
check_sums() {
    local _sumfile="$1"
    assert_nz "$_sumfile" "sumfile"

    # Hackily edit the sha256 file to workaround a bug in the bots' generation of sums
    make_temp_dir
    local _workdir="$RETVAL"
    assert_nz "$_workdir" "workdir"

    sed s/tmp\\/dist\\/.*\\/final\\/// "$_sumfile" > "$_workdir/tmpsums"
    need_ok "failed to generate temporary checksums"

    local _sumfile_dirname="$(dirname "$_sumfile")"
    assert_nz "$_sumfile_dirname" "sumfile_dirname"
    (cd "$_sumfile_dirname" && shasum -c -a 256 "$_workdir/tmpsums" > /dev/null)
    local _sum_retval=$?

    rm -R "$_workdir"
    need_ok "couldn't delete workdir '$_workdir'"

    return $_sum_retval
}

# Verifies that ~/.multirust exists and uses the correct format
check_metadata_version() {
    verbose_say "checking metadata version"

    if [ ! -e "$multirust_dir" ]; then
	verbose_say "creating .multirust directory at \`$multirust_dir\`"
	mkdir -p "$multirust_dir"
	need_ok "failed to create multirust directory"
    fi

    if [ ! -e "$version_file" ]; then
	verbose_say "writing metadata version $metadata_version"
	echo "$metadata_version" > "$version_file"
    else
	local _current_version="$(cat "$version_file")"
	verbose_say "got metadata version $_current_version"
	if [ "$_current_version" != "$metadata_version" ]; then
	    err "metadata version is $_current_version, need $metadata_version. run \`multirust upgrade-data\`"
	fi
    fi
}

get_architecture() {

    verbose_say "detecting architecture"

    local _ostype="$(uname -s)"
    local _cputype="$(uname -m)"

    verbose_say "uname -s reports: $_ostype"
    verbose_say "uname -m reports: $_cputype"

    if [ "$_ostype" = Darwin -a "$_cputype" = i386 ]; then
	# Darwin `uname -s` lies
	if sysctl hw.optional.x86_64 | grep -q ': 1'; then
	    local _cputype=x86_64
	fi
    fi

    case "$_ostype" in

	Linux)
	    local _ostype=unknown-linux-gnu
	    ;;

	FreeBSD)
	    local _ostype=unknown-freebsd
	    ;;

	DragonFly)
	    local _ostype=unknown-dragonfly
	    ;;

	Darwin)
	    local _ostype=apple-darwin
	    ;;

	MINGW* | MSYS*)
	    err "unimplemented windows arch detection"
	    ;;

	*)
	    err "unrecognized OS type: $_ostype"
	    ;;

    esac

    case "$_cputype" in

	i386 | i486 | i686 | i786 | x86)
            local _cputype=i686
            ;;

	xscale | arm)
	    local _cputype=arm
            ;;

	armv7l)
            local _cputype=arm
            local _ostype="${_ostype}eabihf"
            ;;

	x86_64 | x86-64 | x64 | amd64)
            local _cputype=x86_64
            ;;

	*)
            err "unknown CPU type: $CFG_CPUTYPE"

    esac

    # Detect 64-bit linux with 32-bit userland
    if [ $_ostype = unknown-linux-gnu -a $_cputype = x86_64 ]; then
	file -L "$SHELL" | grep -q "x86[_-]64"
	if [ $? != 0 ]; then
	    local _cputype=i686
	fi
    fi

    local _arch="$_cputype-$_ostype" 
    verbose_say "architecture is $_arch"

    RETVAL="$_arch"
}

# Downloads a remote file and its checksum and checks it
download_and_check() {
    local _remote_name="$1"
    local _local_name="$2"
    assert_nz "$_remote_name" "remote name"
    assert_nz "$_local_name" "local name"

    local _remote_sums="$_remote_name.sha256"
    local _local_sums="$_local_name.sha256"

    local _remote_basename="$(basename "$_remote_name")"
    local _remote_sums_basename="$_remote_basename.sha256"
    assert_nz "$_remote_basename" "remote basename"

    make_temp_dir
    local _workdir="$RETVAL"
    assert_nz "$_workdir" "workdir"
    verbose_say "download work dir: $_workdir"

    say "downloading '$_remote_name' to '$_workdir'"
    (cd "$_workdir" && curl -f -O "$_remote_name")
    if [ $? != 0 ]; then
	rm -R "$_workdir"
	err "couldn't download '$_remote_name'"
    fi

    say "downloading '$_remote_sums' to '$_workdir'"
    (cd "$_workdir" && curl -f -O "$_remote_sums")
    if [ $? != 0 ]; then
	rm -R "$_workdir"
	err "couldn't download checksum file '$_remote_sums'"
    fi

    say "verifying checksums for '$_remote_basename'"
    check_sums "$_workdir/$_remote_sums_basename"
    if [ $? != 0 ]; then
	rm -R "$_workdir"
	err "checksum failed for '$_remote_name'"
    fi

    verbose_say "moving '$_workdir/$_remote_basename' to '$_local_name'"
    mv -f "$_workdir/$_remote_basename" "$_local_name"
    if [ $? != 0 ]; then
	rm -R "$_workdir"
	err "couldn't move '$_workdir/$_remote_basename' to '$_local_name'"
    fi

    verbose_say "moving '$_workdir/$_remote_sums_basename' to '$_local_sums'"
    mv -f "$_workdir/$_remote_sums_basename" "$_local_sums"
    if [ $? != 0 ]; then
	rm "$_local_name"
	rm -R "$_workdir"
	err "couldn't move '$_workdir/$_remote_sums_basename' to '$_local_sums'"
    fi

    rm -R "$_workdir"
    need_ok "couldn't delete workdir '$_workdir'"
}

get_local_rust_manifest_name() {
    local _toolchain="$1"
    assert_nz "$_toolchain" "toolchain"

    RETVAL="$manifests_dir/channel-rust-$_toolchain"
}

download_manifest()  {
    local _toolchain="$1"
    local _name="$2"
    local _remote_manifest="$3"
    local _local_manifest="$4"
    assert_nz "$_toolchain" "toolchain"
    assert_nz "$_name" "name"
    assert_nz "$_remote_manifest" "remote manifest"
    assert_nz "$_local_manifest" "local manifest"

    verbose_say "remote $_name manifest: $_remote_manifest"
    verbose_say "local $_name manifest: $_local_manifest"

    verbose_say "creating manifests dir '$manifests_dir'"
    mkdir -p "$manifests_dir"
    need_ok "couldn't create manifests dir"

    say "downloading $_name manifest for '$_toolchain'"
    download_and_check "$_remote_manifest" "$_local_manifest"
}

extract_channel_and_date_from_toolchain() {
    local _toolchain="$1"
    assert_nz "$_toolchain" "toolchain"

    case "$_toolchain" in
	nightly-20[0-9][0-9]-[0-9][0-9]-[0-9][0-9] | \
	beta-20[0-9][0-9]-[0-9][0-9]-[0-9][0-9] | \
	stable-20[0-9][0-9]-[0-9][0-9]-[0-9][0-9] )
	    local _channel="$(echo "$_toolchain" | cut -d- -f1)"
	    local _date="$(echo "$_toolchain" | cut -d- -f2,3,4)"
	    RETVAL_CHANNEL="$_channel"
	    RETVAL_DATE="$_date"
	    ;;

	*)
	    err "unrecognized toolchain spec: $_toolchain"
	    ;;

    esac
}

download_rust_manifest() {
    local _toolchain="$1"
    assert_nz "$_toolchain" "toolchain"

    case "$_toolchain" in
	nightly | beta | stable )
	    local _remote_rust_manifest="$dist_server/$rust_dist_dir/channel-rust-$_toolchain"
	    ;;

	nightly-* | beta-* | stable-* )
	    extract_channel_and_date_from_toolchain "$_toolchain"
	    local _channel="$RETVAL_CHANNEL"
	    local _date="$RETVAL_DATE"
	    assert_nz "$_channel" "channel"
	    assert_nz "$_date" "date"
	    local _remote_rust_manifest="$dist_server/$rust_dist_dir/$_date/channel-rust-$_channel"
	    ;;

	*)
	    err "unrecognized toolchain spec: $_toolchain"
	    ;;

    esac

    get_local_rust_manifest_name "$_toolchain"
    local _local_rust_manifest="$RETVAL"
    assert_nz "$_local_rust_manifest" "local rust manifest"

    download_manifest "$_toolchain" "rust" "$_remote_rust_manifest" "$_local_rust_manifest"
}

get_remote_installer_location_from_manifest() {
    local _toolchain="$1"
    local _manifest_file="$2"
    local _package_name="$3"
    local _dist_dir="$4"
    assert_nz "$_toolchain" "toolchain"
    assert_nz "$_manifest_file" "manifest file"
    assert_nz "$_package_name" "package name"
    assert_nz "$_dist_dir" "dist dir"

    if [ ! -e "$_manifest_file" ]; then
	err "manifest file '$_manifest_file' does not exist"
    fi

    get_architecture
    local _arch="$RETVAL"
    assert_nz "$_arch" "arch"

    while read _line; do
	# This regex checks for the version in addition to the package name because there
	# are package names that are substrings of other packages, 'rust-docs' vs. 'rust'.
	echo "$_line" | egrep "^$_package_name-(nightly|beta|alpha|[0-9]).*$_arch\.tar\.gz" > /dev/null
	if [ $? = 0 ]; then
	    case "$_toolchain" in
		nightly | beta | stable )
		    RETVAL="$dist_server/$_dist_dir/$_line"
		    ;;

		nightly-* | beta-* | stable-* )
		    extract_channel_and_date_from_toolchain "$_toolchain"
		    local _channel="$RETVAL_CHANNEL"
		    local _date="$RETVAL_DATE"
		    assert_nz "$_channel" "channel"
		    assert_nz "$_date" "date"
		    RETVAL="$dist_server/$_dist_dir/$_date/$_line"
		    ;;

		*)
		    err "unrecognized toolchain spec: $_toolchain"
		    ;;
	    esac
	    return
	fi
    done < "$_manifest_file"

    err "couldn't find remote installer for '$_arch' in manifest"
}

determine_remote_rust_installer_location() {
    local _toolchain="$1"
    assert_nz "$_toolchain" "toolchain"

    verbose_say "determining remote rust installer for '$_toolchain'"

    case "$_toolchain" in
	nightly | beta | stable | nightly-* | beta-* | stable-* )
	    download_rust_manifest "$_toolchain"
	    get_local_rust_manifest_name "$_toolchain"
	    local _manifest_file="$RETVAL"
	    assert_nz "$_manifest_file" "manifest file"
	    get_remote_installer_location_from_manifest "$_toolchain" "$_manifest_file" $rust_package_name "$rust_dist_dir"
	    return
	    ;;

	* )
	    say "interpreting toolchain spec as explicit version"
	    get_architecture
	    local _arch="$RETVAL"
	    assert_nz "$_arch" "arch"

	    local _file_name="rust-$_toolchain-$_arch.tar.gz"
	    RETVAL="$dist_server/$rust_dist_dir/$_file_name"
	    return
	    ;;
    esac
}

get_toolchain_dir() {
    local _toolchain="$1"
    assert_nz "$_toolchain" "toolchain"

    RETVAL="$toolchains_dir/$_toolchain"
}

is_toolchain_installed() {
    local _toolchain="$1"
    assert_nz "$_toolchain" "toolchain"

    verbose_say "looking for installed toolchain '$_toolchain'"

    get_toolchain_dir "$_toolchain"
    local _toolchain_dir="$RETVAL"
    assert_nz "$_toolchain_dir" "toolchain dir"

    if [ -e "$_toolchain_dir" ]; then
	RETVAL=true
	return
    fi

    RETVAL=false
}

install_toolchain() {
    local _toolchain="$1"
    assert_nz "$_toolchain" "toolchain"

    determine_remote_rust_installer_location "$_toolchain"
    local _remote_rust_installer="$RETVAL"
    assert_nz "$_remote_rust_installer" "remote rust installer"
    verbose_say "remote rust installer location: $_remote_rust_installer"

    verbose_say "creating toolchains dir '$toolchains_dir'"
    mkdir -p "$toolchains_dir"
    need_ok "failed to make toolchain dir"

    local _rust_installer_name="$(basename "$_remote_rust_installer")"
    assert_nz "$_rust_installer_name" "rust installer name"

    # Create a temp directory to put the downloaded toolchain
    make_temp_dir
    local _workdir="$RETVAL"
    assert_nz "$_workdir" "workdir"
    verbose_say "download work dir: $_workdir"

    # Download the toolchain
    say "downloading rust installer from '$_remote_rust_installer'"
    download_and_check "$_remote_rust_installer" "$_workdir/$_rust_installer_name"

    local _rust_installer_dir="$(echo "$_rust_installer_name" | sed s/.tar.gz$//)"
    assert_nz "$_rust_installer_dir" "rust installer dir"

    # Extract the toolchain
    (cd "$_workdir" && tar xzf "$_rust_installer_name")
    if [ $? != 0 ]; then
	rm -R "$_workdir"
	err "failed to extract rust installer"
    fi

    # Install the toolchain
    get_toolchain_dir "$_toolchain"
    local _toolchain_dir="$RETVAL"
    assert_nz "$_toolchain_dir" "toolchain dir"
    verbose_say "installing toolchain to '$_toolchain_dir'"
    say "installing toolchain for '$_toolchain'"

    mkdir -p "$_toolchain_dir"
    if [ $? != 0 ]; then
	rm -R "$_workdir"
	err "failed to create toolchain install dir"
    fi

    sh "$_workdir/$_rust_installer_dir/install.sh" --prefix="$_toolchain_dir" --disable-ldconfig
    if [ $? != 0 ]; then
	rm -R "$_toolchain_dir"
	rm -R "$_workdir"
	err "failed to install toolchain"
    fi

    # Remove this toolchain from the update list
    if [ -e "$update_list_file" ]; then
	verbose_say "removing $_toolchain from update list"
	sed /^"$_toolchain"$/d "$update_list_file" > "$_workdir/newlist"
	if [ $? != 0 ]; then
	    rm -R "$_workdir"
	    err "failed to modify update list"
	fi
	mv -f "$_workdir/newlist" "$update_list_file"
	if [ $? != 0 ]; then
	    rm -R "$_workdir"
	    err "failed to modify update list"
	fi
    fi

    # If this is from a release channel save the installer checksum for
    # use in checking for updates later
    case "$_toolchain" in
	nightly | beta | sable )
	    local _saved_sumfile="$channel_sums_dir/$_toolchain.sha256"
	    verbose_say "saving checksums to $_saved_sumfile"
	    mkdir -p "$channel_sums_dir"
	    need_ok "failed to crate channel sums dir"
	    cp "$_workdir/$_rust_installer_name.sha256" "$_saved_sumfile"
	    need_ok "failed to save channel checksums"
	    ;;
    esac

    rm -R "$_workdir"
    need_ok "couldn't delete workdir"
}

install_toolchain_if_not_installed() {
    local _toolchain="$1"
    assert_nz "$_toolchain" "toolchain"

    is_toolchain_installed "$_toolchain"
    if [ "$RETVAL" = true ]; then
	say "using existing install for '$_toolchain'"
	return 0
    else
	say "installing toolchain '$_toolchain'"
	install_toolchain "$_toolchain"
    fi
}

update_toolchain() {
    local _toolchain="$1"
    assert_nz "$_toolchain" "toolchain"

    is_toolchain_installed "$_toolchain"
    if [ "$RETVAL" = true ]; then
	say "updating existing install for '$_toolchain'"
    else
	say "installing toolchain '$_toolchain'"
    fi

    install_toolchain "$_toolchain"
}

remove_toolchain() {
    local _toolchain="$1"
    assert_nz "$_toolchain" "toolchain"

    local _toolchain_dir="$toolchains_dir/$_toolchain"

    if [ -e "$_toolchain_dir" ]; then
	verbose_say "removing directory '$_toolchain_dir'"
	# Need to use -f because it contains Cargo's git directories
	rm -Rf "$_toolchain_dir"
	need_ok "failed to remove toolchain"
	say "toolchain '$_toolchain' uninstalled"
    else
	say "no toolchain installed for '$_toolchain'"
    fi
}

find_default() {
    if [ ! -e "$default_file" ]; then
	err 'no default toolchain configured. run `multirust help default`'
    fi

    local _default="$(cat "$default_file")"
    assert_nz "_$default" "default file is empty"

    get_toolchain_dir "$_default"
    local _sysroot="$RETVAL"
    assert_nz "$_sysroot" "sysroot"
    
    if [ ! -d "$_sysroot" ]; then
	err "toolchain '$_default' not installed. run \`multirust update $_default\` to install"
    fi

    RETVAL_TOOLCHAIN="$_default"
    RETVAL_SYSROOT="$_sysroot"
}

find_override() {
    if [ ! -e "$override_db" ]; then
	return 1
    fi

    local _dir="$(pwd)"
    assert_nz "$_dir" "empty starting dir"

    # Go up the directory hierarchy looking for overrides
    while [ "$_dir" != "/" -a "$_dir" != "." ]; do
	while read _line; do
	    local _ovrdir="$(echo "$_line" | cut -f1)"
	    need_ok "extracting record from db failed"
	    assert_nz "$_ovrdir" "empty dir in override db"
	    local _toolchain="$(echo "$_line" | cut -f2)"
	    need_ok "extracting record from db failed"
	    assert_nz "$_toolchain" "empty toolchain in override db"

	    if [ "$_dir" = "$_ovrdir" ]; then
		RETVAL_OVRDIR="$_ovrdir"
		RETVAL_TOOLCHAIN="$_toolchain"
		get_toolchain_dir "$_toolchain"
		RETVAL_SYSROOT="$RETVAL"
		if [ ! -e "$RETVAL_SYSROOT" ]; then
		    err "toolchain '$_toolchain' not installed. run \`multirust update $_toolchain\` to install"
		fi
		return
	    fi
	done < "$override_db"

	local _dir="$(dirname $_dir)"
    done

    return 1
}

find_override_sysroot_or_default() {
    if find_override; then
	RETVAL="$RETVAL_SYSROOT"
	return
    fi

    find_default
    RETVAL="$RETVAL_SYSROOT"
}

print_override_sysroot_or_default() {
    find_override_sysroot_or_default
    echo "$RETVAL"
}

set_default() {
    local _toolchain="$1"
    assert_nz "$_toolchain" "toolchain"

    make_temp
    local _workfile="$RETVAL"
    assert_nz "$_workfile" "workfile"

    echo "$_toolchain" > "$_workfile"
    if [ $? != 0 ]; then
	rm -R "$_workfile"
	err "couldn't write default toolchain to tempfile"
    fi

    mv -f "$_workfile" "$default_file"
    if [ $? != 0 ]; then
	rm -R "$_workfile"
	err "couldn't set default toolchain"
    fi

    say "default toolchain set to '$_toolchain'"
}

set_override() {
    local _toolchain="$1"
    assert_nz "$_toolchain" "toolchain"

    local _override_dir="$(pwd)"
    assert_nz "$_override_dir" "empty pwd?"

    # Escape forward-slashes
    local _escaped_override_dir=`echo "$_override_dir" | sed s/\\\//\\\\\\\\\\\//g`

    make_temp
    local _workfile="$RETVAL"
    assert_nz "$_workfile" "workfile"

    # Copy the current db to a new file, removing any existing override
    if [ -e "$override_db" ]; then
	# Escape the tab because OS X sed won't
	local _tab="$(echo '\t' | awk '/\t/')"
	sed "/^$_escaped_override_dir$_tab/d" "$override_db" > "$_workfile"
	if [ $? != 0 ]; then
	    rm -R "$_workfile"
	    err "unable to edit override db"
	fi
    fi

    # Escape the tab
    local _line="$(echo "$_override_dir\t$_toolchain" | awk /\t/)"
    # Append the new override
    echo "$_line" >> "$_workfile"
    if [ $? != 0 ]; then
	rm -R "$_workfile"
	err "unable to edit override db"
    fi

    # Move it back to the database
    mv -f "$_workfile" "$override_db"
    need_ok "unable to edit override db"

    say "override toolchain for '$_override_dir' set to '$_toolchain'"
}

remove_override() {
    local _override_dir="$(pwd)"
    assert_nz "$_override_dir" "empty pwd?"

    # Escape forward-slashes
    local _escaped_override_dir=`echo "$_override_dir" | sed s/\\\//\\\\\\\\\\\//g`

    make_temp
    local _workfile="$RETVAL"
    assert_nz "$_workfile" "workfile"

    # Check if the override exists
    local _have_override=false
    if [ -e "$override_db" ]; then
	# Get an actual tab character because grep doesn't interpret \t
	local _tab="$(echo '\t' | awk '/\t/')"
	egrep "^$_escaped_override_dir$_tab" "$override_db" > /dev/null
	if [ $? = 0 ]; then
	    local _have_override=true
	fi
    fi
    if [ $_have_override = false ]; then
	say "no override for current directory '$_override_dir'"
	return
    fi

    # Copy the current db to a new file, removing any existing override
    if [ -e "$override_db" ]; then
	local _tab="$(echo '\t' | awk '/\t/')"
	sed "/^$_escaped_override_dir$_tab/d" "$override_db" > "$_workfile"
	if [ $? != 0 ]; then
	    rm -R "$_workfile"
	    err "unable to edit override db"
	fi
    fi

    # Move it back to the database
    mv -f "$_workfile" "$override_db"
    need_ok "unable to edit override db"

    say "override toolchain for '$_override_dir' removed"
}

push_toolchain_ldpath() {
    local _toolchain="$1"
    assert_nz "$_toolchain" "toolchain"

    get_toolchain_dir "$_toolchain"
    local _toolchain_dir="$RETVAL"
    local _new_path="$_toolchain_dir/lib"

    OLD_LD_LIBRARY_PATH="$LD_LIBRARY_PATH"
    LD_LIBRARY_PATH="$_new_path:$LD_LIBRARY_PATH"
    export LD_LIBRARY_PATH

    OLD_DYLD_LIBRARY_PATH="$DYLD_LIBRARY_PATH"
    DYLD_LIBRARY_PATH="$_new_path:$DYLD_LIBRARY_PATH"
    export DYLD_LIBRARY_PATH
}

pop_toolchain_ldpath() {
    LD_LIBRARY_PATH="$OLD_LD_LIBRARY_PATH"
    export LD_LIBRARY_PATH
    DYLD_LIBRARY_PATH="$OLD_DYLD_LIBRARY_PATH"
    export DYLD_LIBRARY_PATH
}

show_default() {
    if find_default; then
	local _toolchain="$RETVAL_TOOLCHAIN"
	local _sysroot="$RETVAL_SYSROOT"

	say "default toolchain: $_toolchain"
	say "default location: $_sysroot"

	push_toolchain_ldpath "$_toolchain"

	echo

	"$_sysroot/bin/rustc" --version
	"$_sysroot/bin/cargo" --version

	pop_toolchain_ldpath
    else
	say "no default"
    fi
}

show_override() {
    if find_override; then
	local _ovrdir="$RETVAL_OVRDIR"
	local _toolchain="$RETVAL_TOOLCHAIN"
	local _sysroot="$RETVAL_SYSROOT"

	say "override directory: $_ovrdir"
	say "override toolchain: $_toolchain"
	say "override location: $_sysroot"

	push_toolchain_ldpath "$_toolchain"

	echo

	"$_sysroot/bin/rustc" --version
	"$_sysroot/bin/cargo" --version

	pop_toolchain_ldpath
    else
	say "no override"
    fi
}

list_overrides() {
    if [ -e "$override_db" ]; then
	local _overrides="$(cat "$override_db" | sort)"
	if [ -n "$_overrides" ]; then
	    echo "$_overrides"
	else
	    say "no overrides"
	fi
    else
	say "no overrides"
    fi
}

list_toolchains() {
    if [ -e "$toolchains_dir" ]; then
	local _toolchains="$(cd "$toolchains_dir" && ls | sort)"
	if [ -n "$_toolchains" ]; then
	    echo "$_toolchains"
	else
	    say "no installed toolchains"
	fi
    else
	say "no installed toolchains"
    fi
}

delete_data() {
    if [ ! "$flag_yes" = true ]; then
	read -p "This will delete all toolchains, overrides, aliases, and other multirust data associated with this user. Continue? (y/n) " yn

	case "$yn" in
	    [Nn] )
		exit 0
		;;
	esac
    fi

    # Need -f for Cargo's write-protected git directories
    rm -Rf "$multirust_dir"
    need_ok "failed to delete '$multirust_dir'"
}

maybe_print_update_notice_for_override() {
    if find_override; then
	local _toolchain="$RETVAL_TOOLCHAIN"
    else
	find_default
	local _toolchain="$RETVAL_TOOLCHAIN"
    fi

    if [ -e "$update_list_file" ]; then
	if grep -q "$_toolchain" "$update_list_file" ; then
	    say "a new version of '$_toolchain' is available. run \`multirust update $_toolchain\` to install it"
	fi
    fi
}

maybe_check_for_updates_async() {
    local _now="$(date +%F)"
    local _need_update=true
    if [ -e "$update_stamp_file" ]; then
	local _update_time="$(cat "$update_stamp_file")"
	if [ "$_now" = "$_update_time" ]; then
	    local _need_update=false
	fi
    fi

    if [ "$_need_update" = true ]; then
	verbose_say "update timestamp out of date. checking for updates"
	echo "$_now" > "$update_stamp_file"
	# Call multirust recursively in background to look for updates
	call_multirust ctl check-updates-sync &
    else
	verbose_say "update timestamp up to date. not checking for updates"
    fi
}

# Checks whether the checksums of the available nightly/beta/stable installers differ
# from the installed toolchains, and if so adds the channel to the update list so
# later invocations of multirust can notify the user.
check_for_updates_sync() {
    for _channel in nightly beta stable; do
	if [ -e "$update_list_file" ]; then
	    if grep -q "$_channel" "$update_list_file"; then
		verbose_say "channel '$_channel' already needs update. skipping"
		continue
	    fi
	fi

	determine_remote_rust_installer_location "$_channel"
	local _remote_rust_installer="$RETVAL"
	assert_nz "$_remote_rust_installer" "remote rust installer"

	local _local_sumfile="$channel_sums_dir/$_channel.sha256"
	local _remote_sumfile="$_remote_rust_installer.sha256"
	verbose_say "local sumfile: $_local_sumfile"
	verbose_say "remote sumfile: $_remote_sumfile"
	if [ -e "$_local_sumfile" ]; then
	    verbose_say "checking for updates on $_channel"
	    make_temp_dir
	    local _workdir="$RETVAL"
	    assert_nz "$_workdir" "workdir"
	    verbose_say "update work dir: $_workdir"

	    (cd "$_workdir" && curl -f -O "$_remote_sumfile" > /dev/null 2>&1)
	    if [ $? != 0 ]; then
		verbose_say "couldn't download checksums for $_channel"
	    else
		local _local_sum="$(cat "$_local_sumfile")"
		local _new_sum="$(cat "$_workdir/$_sumfile")"

		if [ "$_local_sum" != "$_new_sum" ]; then
		    if [ -e "$update_list_file" ]; then
			local _newlist="$_workdir/newlist"
			cp "$update_list_file" "$_newlist"
			if [ $? != 0 ]; then
			    rm -R "$_workdir"
			    err "couldn't delete copy update list"
			fi

			if ! grep -q "$_channel" "$_newlist"; then
			    verbose_say "adding $_channel to existing update list"
			    echo "$_channel" >> "$_newlist"
			    if [ $? != 0 ]; then
				rm -R "$_workdir"
				err "couldn't append update list"
			    fi
			    mv -f "$_newlist" "$update_list_file"
			    if [ $? != 0 ]; then
				rm -R "$_workdir"
				err "couldn't replace update list"
			    fi
			else
			    # This should be rare since we've already avoided doing the download
			    # if the channel was in the list. But could be possible with races
			    # in multiple invocations.
			    verbose_say "channel $_channel already in update list"
			fi
		    else # Update list does not exist
			verbose_say "adding $_channel to new update list"
			local _newlist="$_workdir/newlist"
			echo "$_channel" > "$_newlist"
			if [ $? != 0 ]; then
			    rm -R "$_workdir"
			    err "couldn't append update list"
			fi
			mv -f "$_newlist" "$update_list_file"
			if [ $? != 0 ]; then
			    rm -R "$_workdir"
			    err "couldn't replace update list"
			fi
		    fi
		fi

		rm -R "$_workdir"
		need_ok "couldn't delete workdir"
	    fi
	else # Channel not installed
	    verbose_say "channel '$_channel' not installed. not checking for updates"
	fi
    done
}

# Check for some global options
for opt in "$@"; do
    case "$opt" in
	--verbose)
	    flag_verbose=true
	    ;;

	-y | --yes)
	    flag_yes=true
	    ;;

	--version)
	    echo "multirust $version ($commit_version)"
	    exit 0
	    ;;

    esac
done

if [ -n "$MULTIRUST_VERBOSE" ]; then
    flag_verbose=true
fi

cmd="$1"

# Make sure our data is in the correct format
check_metadata_version

case "$cmd" in
    default)
	if [ -z "$2" ]; then
	    err 'unspecified default toolchain. try `multirust help default`'
	fi
	install_toolchain_if_not_installed "$2"
	set_default "$2"
	;;

    override)
	if [ -z "$2" ]; then
	    err 'unspecified override toolchain. try `multirust help override`'
	fi
	install_toolchain_if_not_installed "$2"
	set_override "$2"
	;;

    alias)
	err "unimplemented"
	;;

    update)
	if [ -z "$2" ]; then
	    err 'unspecified update toolchain. try `multirust help update`'
	fi
	update_toolchain "$2"
	;;

    show-default)
	show_default
	;;

    show-override)
	show_override
	;;

    list-overrides)
	list_overrides
	;;

    list-toolchains)
	list_toolchains
	;;

    remove-override)
	remove_override
	;;

    remove-toolchain)
	if [ -z "$2" ]; then
	    err 'unspecified toolchain. try `multirust help remove-toolchain`'
	fi
	remove_toolchain "$2"
	;;

    remove-alias)
	err "unimplemented"
	;;

    delete-data)
	delete_data
	;;

    upgrade-data)
	err "unimplemented"
	;;

    gc)
	err "unimplemented"
	;;

    ctl)
	case "$2" in
	    override-sysroot)
		print_override_sysroot_or_default
		;;

	    check-updates-override)
		maybe_print_update_notice_for_override
		maybe_check_for_updates_async
		;;

	    check-updates-sync)
		check_for_updates_sync
		;;

	    "")
		err 'empty ctl command. try `multirust help ctl`'
		;;

	    *)
		err "unrecognized ctl comand \`$2\`. try \`multirust help ctl\`"
		;;
	esac
	;;

    help)
	case "$2" in
	    default)
		help_default
		;;
	    override)
		help_override
		;;
	    update)
		help_update
		;;
	    show-default)
		help_show_default
		;;
	    show-override)
		help_show_override
		;;
	    list-overrides)
		help_list_overrides
		;;
	    list-toolchains)
		help_list_toolchains
		;;
	    remove-override)
		help_remove_override
		;;
	    remove-toolchain)
		help_remove_toolchain
		;;
	    delete-data)
		help_delete_data
		;;
	    ctl)
		help_ctl
		;;
	    help)
		help
		;;
	    "") help
		;;
	    *)
		err "unrecognized command \`$2\`"
		;;
	esac
	;;

    *)
	help
	;;
esac

exit 0
