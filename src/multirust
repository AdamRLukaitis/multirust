#!/bin/sh

help() {
    echo "Usage: multirust <command> [--verbose] [--version]"
    echo
    echo "Commands:"
    echo
    echo "    default          Set the default toolchain"
    echo "    override         Set the toolchain override for the current directory tree"
    echo "    alias            Create alias commands for a toolchain"
    echo "    update           Update a given toolchain"
    echo "    show-default     Show information about the current default"
    echo "    show-override    Show information about the current override"
    echo "    list-overrides   List all overrides"
    echo "    list-toolchains  List all installed toolchains"
    echo "    remove-override  Remove the current override"
    echo "    remove-toolchain Uninstall a toolchain"
    echo "    remove-alias     Delete alias toolchain commands"
    echo "    delete-data      Delete all user metadata, including installed toolchains"
    echo "    upgrade-data     Upgrade user metadata from previous versions"
    echo "    gc               Delete unused toolchains"
    echo "    help             Show help for this command or subcommands"
    echo
    echo "Use \`multirust help <command>\` for detailed help."
}

help_default() {
    echo "Installs and configures the default toolchain."
    echo
    echo "Usage: multirust default <toolchain>"
}

help_override() {
    echo "Installs and configures a toolchain that will override the default"
    echo "when working at or below the current directory."
    echo
    echo "To remove an existing override use \`multirust remove-override\`."
    echo
    echo "Usage: multirust override <toolchain>"
}

help_update() {
    echo "Updates an installed toolchain or installs from scratch if it is"
    echo "not yet installed."
    echo
    echo "Usage: multirust update <toolchain>"
}

help_show_default() {
    echo "Displays information about the default toolchain."
    echo
    echo "Usage: multirust show-default"
}

help_show_override() {
    echo "Displays information about the current toolchain override."
    echo
    echo "Usage: multirust show-override"
}

help_list_overrides() {
    echo "Displays a list of all overrides."
    echo
    echo "Usage: multirust list-overrides"
}

help_list_toolchains() {
    echo "Displays a list of all toolchains."
    echo
    echo "Usage: multirust list-toolchains"
}

help_remove_override() {
    echo "Removes the override for the current directory."
    echo
    echo "Usage: multirust remove-override"
}

help_remove_toolchain() {
    echo "Uninstalls an installed toolchain."
    echo
    echo "Usage: multirust remove-toolchain <toolchain>"
}

help_delete_data() {
    echo "Deletes the ~/.multirust directory, removing all installed toolchains,"
    echo "overrides, and aliases for the current user."
    echo
    echo "Prompts for confirmation. Disable prompt with -y."
    echo
    echo "Does not delete global aliases."
    echo
    echo "Usage: multirust delete-data [-y]."
}

# Some utilities

say() {
    echo "multirust: $1"
}

verbose_say() {
    if [ "$flag_verbose" = true ]; then
	say "$1"
    fi
}

err() {
    say "$1" >&2
    exit 1
}

need_cmd() {
    if ! command -v $1 > /dev/null 2>&1
    then err "need $1"
    fi
}

need_ok() {
    if [ $? != 0 ]; then err "$1"; fi
}

assert_nz() {
    if [ -z "$1" ]; then err "assert_nz $2"; fi
}

# Ensure various commands exist
need_cmd dirname
need_cmd basename
need_cmd mkdir
need_cmd cat
need_cmd curl
need_cmd mktemp
need_cmd rm
need_cmd egrep
need_cmd grep
need_cmd file
need_cmd uname
need_cmd tar
need_cmd sed
need_cmd sh
need_cmd mv
need_cmd awk
need_cmd cut
need_cmd sort

# Environment sanity checks
assert_nz "$HOME" "\$HOME is undefined"
assert_nz "$0" "\$0 is undefined"

# Some constants
version=0.0.1
metadata_version=1
dist_server="${MULTIRUST_DIST_SERVER-https://static.rust-lang.org}"
rust_dist_dir=dist
cargo_dist_dir=cargo-dist
default_spec=nightly
cmd_dirname=$(dirname "$0")
cmd_basename=$(basename "$0")
abs_cmd_basename=$(cd "$cmd_dirname" && pwd)
multirust_dir="$HOME/.multirust"
version_file="$multirust_dir/version"
override_db="$multirust_dir/overrides"
default_file="$multirust_dir/default"
toolchains_dir="$multirust_dir/tcs"
manifests_dir="$multirust_dir/manifests"
temp_dir="$multirust_dir/tmp"

# Some globals
flag_verbose=false
flag_yes=false

make_temp() {
    _old_tmpdir="$TMPDIR"
    TMPDIR="$temp_dir"
    export TMPDIR
    mktemp tmp.XXXXXXXXXX
    _retval=$?
    TMPDIR="$_old_tmpdir"
    export TMPDIR
    return $_retval
}

make_temp_dir() {
    _old_tmpdir="$TMPDIR"
    TMPDIR="$temp_dir"
    export TMPDIR
    mktemp -d tmp.XXXXXXXXXX
    _retval=$?
    TMPDIR="$_old_tmpdir"
    export TMPDIR
    return $_retval
}

# Verifies that ~/.multirust exists and uses the correct format
check_metadata_version() {
    verbose_say "checking metadata version"

    if [ ! -e "$multirust_dir" ]; then
	verbose_say "creating .multirust directory at \`$multirust_dir\`"
	mkdir -p "$multirust_dir"
	need_ok "failed to create multirust directory"
    fi

    if [ ! -e "$version_file" ]; then
	verbose_say "writing metadata version $metadata_version"
	echo "$metadata_version" > "$version_file"
    else
	_current_version=$(cat "$version_file")
	verbose_say "got metadata version $_current_version"
	if [ "$_current_version" != "$metadata_version" ]; then
	    err "metadata version is $_current_version, need $metadata_version. run \`multirust upgrade-data\`"
	fi
    fi
}

get_architecture() {

    verbose_say "detecting architecture"

    _ostype=$(uname -s)
    _cputype=$(uname -m)

    verbose_say "uname -s reports: $_ostype"
    verbose_say "uname -m reports: $_cputype"

    if [ "$_ostype" = Darwin -a "$_cputype" = i386 ]; then
	# Darwin `uname -s` lies
	if sysctl hw.optional.x86_64 | grep -q ': 1'; then
	    _cputype=x86_64
	fi
    fi

    case "$_ostype" in

	Linux)
	    _ostype=unknown-linux-gnu
	    ;;

	FreeBSD)
	    _ostype=unknown-freebsd
	    ;;

	DragonFly)
	    _ostype=unknown-dragonfly
	    ;;

	Darwin)
	    _ostype=apple-darwin
	    ;;

	MINGW* | MSYS*)
	    err "unimplemented windows arch detection"
	    ;;

	*)
	    err "unrecognized OS type: $_ostype"
	    ;;

    esac

    case "$_cputype" in

	i386 | i486 | i686 | i786 | x86)
            _cputype=i686
            ;;

	xscale | arm)
	    _cputype=arm
            ;;

	armv7l)
            _cputype=arm
            _ostype="${_ostype}eabihf"
            ;;

	x86_64 | x86-64 | x64 | amd64)
            _cputype=x86_64
            ;;

	*)
            err "unknown CPU type: $CFG_CPUTYPE"

    esac

    # Detect 64-bit linux with 32-bit userland
    if [ $_ostype = unknown-linux-gnu -a $_cputype = x86_64 ]; then
	file -L "$SHELL" | grep -q "x86[_-]64"
	if [ $? != 0 ]; then
	    _cputype=i686
	fi
    fi

    _arch="$_cputype-$_ostype" 
    verbose_say "architecture is $_arch"

    RETVAL="$_arch"
}

get_local_cargo_manifest_name() {
    RETVAL="$manifests_dir/channel-cargo-nightly"
}

get_local_rust_manifest_name() {
    _toolchain="$1"
    assert_nz "$_toolchain" "toolchain"

    RETVAL="$manifests_dir/channel-rustc-$_toolchain"
}

download_manifest()  {
    _toolchain="$1"
    _name="$2"
    _remote_manifest_basename="$3"
    _remote_manifest="$4"
    _local_manifest="$5"
    assert_nz "$_toolchain" "toolchain"
    assert_nz "$_name" "name"
    assert_nz "$_remote_manifest_basename" "remote basename"
    assert_nz "$_remote_manifest" "remote manifest"
    assert_nz "$_local_manifest" "local manifest"

    verbose_say "remote $_name manifest: $_remote_manifest"
    verbose_say "local $_name manifest: $_local_manifest"

    verbose_say "creating manifests dir '$manifests_dir'"
    mkdir -p "$manifests_dir"
    need_ok "couldn't create manifests dir"

    verbose_say "creating temp dir: '$temp_dir'"
    mkdir -p "$temp_dir"
    need_ok "couldn't make temp dir"
    _workdir=$(make_temp_dir)
    need_ok "culdn't make work dir"
    assert_nz "$_workdir" "workdir"
    verbose_say "manifest work dir: $_workdir"

    # Check for future rust installer changes
    _future_manifest="$dist_server/$rust_dist_dir/channel-rust-nightly"
    say "checking for future manifest"
    (cd "$_workdir" && curl -f -O "$_future_manifest" > /dev/null 2>&1)
    if [ $? = 0 ]; then
	err "remote channel manifest uses future format. upgrade multirust"
    fi

    say "downloading $_name manifest for '$_toolchain'"
    (cd "$_workdir" && curl -f -O "$_remote_manifest")
    if [ $? != 0 ]; then
	rm -R "$_workdir"
	err "couldn't download manifest"
    fi

    mv -f "$_workdir/$_remote_manifest_basename" "$_local_manifest"
    if [ $? != 0 ]; then
	rm -R "$_workdir"
	err "couldn't copy manifest"
    fi

    rm -R "$_workdir"
    need_ok "couldn't delete workdir"
}

extract_channel_and_date_from_toolchain() {
    _toolchain="$1"
    assert_nz "$_toolchain" "toolchain"

    case "$_toolchain" in
	nightly-20[0-9][0-9]-[0-9][0-9]-[0-9][0-9] | \
	beta-20[0-9][0-9]-[0-9][0-9]-[0-9][0-9] | \
	stable-20[0-9][0-9]-[0-9][0-9]-[0-9][0-9] )
	    _channel=$(echo "$_toolchain" | cut -d- -f1)
	    _date=$(echo "$_toolchain" | cut -d- -f2,3,4)
	    RETVAL_CHANNEL="$_channel"
	    RETVAL_DATE="$_date"
	    ;;

	*)
	    err "unrecognized toolchain spec: $_toolchain"
	    ;;

    esac
}

download_rust_manifest() {
    _toolchain="$1"
    assert_nz "$_toolchain" "toolchain"

    case "$_toolchain" in
	nightly | beta | stable )
	    _remote_rust_basename="channel-rustc-$_toolchain"
	    _remote_rust_manifest="$dist_server/$rust_dist_dir/$_remote_rust_basename"
	    ;;

	nightly-* | beta-* | stable-* )
	    extract_channel_and_date_from_toolchain "$_toolchain"
	    _channel="$RETVAL_CHANNEL"
	    _date="$RETVAL_DATE"
	    assert_nz "$_channel" "channel"
	    assert_nz "$_date" "date"
	    _remote_rust_basename="channel-rustc-$_channel"
	    _remote_rust_manifest="$dist_server/$rust_dist_dir/$_date/$_remote_rust_basename"
	    ;;

	*)
	    err "unrecognized toolchain spec: $_toolchain"
	    ;;

    esac

    get_local_rust_manifest_name "$_toolchain"
    _local_rust_manifest="$RETVAL"
    assert_nz "$_local_rust_manifest" "local rust manifest"

    download_manifest "$_toolchain" "rust" "$_remote_rust_basename" \
	"$_remote_rust_manifest" "$_local_rust_manifest"
}

download_cargo_manifest() {
    _remote_cargo_basename="channel-cargo-nightly"
    _remote_cargo_manifest="$dist_server/$cargo_dist_dir/$_remote_cargo_basename"

    get_local_cargo_manifest_name
    _local_cargo_manifest="$RETVAL"
    assert_nz "$_local_cargo_manifest" "local cargo manifest"

    download_manifest "$_toolchain" "cargo" "$_remote_cargo_basename" \
	"$_remote_cargo_manifest" "$_local_cargo_manifest"
}

get_remote_installer_location_from_manifest() {
    _toolchain="$1"
    _manifest_file="$2"
    _package_name="$3"
    _dist_dir="$4"
    assert_nz "$_toolchain" "toolchain"
    assert_nz "$_manifest_file" "manifest file"
    assert_nz "$_package_name" "package name"
    assert_nz "$_dist_dir" "dist dir"

    if [ ! -e "$_manifest_file" ]; then
	err "manifest file '$_manifest_file' does not exist"
    fi

    get_architecture
    _arch="$RETVAL"
    assert_nz "$_arch" "arch"

    while read _line; do
	# This regex checks for the version in addition to the package name because there
	# are package names that are substrings of other packages, 'rust-docs' vs. 'rust'.
	echo "$_line" | egrep "^$_package_name-(nightly|beta|alpha|[0-9]).*$_arch\.tar\.gz" > /dev/null
	if [ $? = 0 ]; then
	    if [ "$_package_name" = "cargo" ]; then
		# Cargo is always downloaded from current nightly
		RETVAL="$dist_server/$_dist_dir/$_line"
	    else
		case "$_toolchain" in
		    nightly | beta | stable )
			RETVAL="$dist_server/$_dist_dir/$_line"
			;;

		    nightly-* | beta-* | stable-* )
			extract_channel_and_date_from_toolchain "$_toolchain"
			_channel="$RETVAL_CHANNEL"
			_date="$RETVAL_DATE"
			assert_nz "$_channel" "channel"
			assert_nz "$_date" "date"
			RETVAL="$dist_server/$_dist_dir/$_date/$_line"
			;;

		    *)
			err "unrecognized toolchain spec: $_toolchain"
			;;
		esac
	    fi
	    return
	fi
    done < "$_manifest_file"

    err "couldn't find remote installer for '$_arch' in manifest"
}

determine_remote_rust_installer_location() {
    _toolchain="$1"
    assert_nz "$_toolchain" "toolchain"

    verbose_say "determining remote rust installer for '$_toolchain'"

    case "$_toolchain" in
	nightly | beta | stable | nightly-* | beta-* | stable-* )
	    download_rust_manifest "$_toolchain"
	    get_local_rust_manifest_name "$_toolchain"
	    _manifest_file="$RETVAL"
	    assert_nz "$_manifest_file" "manifest file"
	    get_remote_installer_location_from_manifest "$_toolchain" "$_manifest_file" "rust" "$rust_dist_dir"
	    return
	    ;;

	* )
	    verbose_say "interpreting toolchain spec as explicit version"
	    get_architecture
	    _arch="$RETVAL"
	    assert_nz "$_arch" "arch"

	    _file_name="rust-$_toolchain-$_arch.tar.gz"
	    RETVAL="$dist_server/$rust_dist_dir/$_file_name"
	    return
	    ;;
    esac
}

determine_remote_cargo_installer_location() {
    _toolchain="$1"
    assert_nz "$_toolchain" "toolchain"

    verbose_say "determining remote cargo installer for '$_toolchain'"

    download_cargo_manifest "$_toolchain"
    get_local_cargo_manifest_name
    _manifest_file="$RETVAL"
    assert_nz "$_manifest_file" "manifest file"
    get_remote_installer_location_from_manifest "$_toolchain" "$_manifest_file" "cargo" "$cargo_dist_dir"
}

get_toolchain_dir() {
    _toolchain="$1"
    assert_nz "$_toolchain" "toolchain"

    RETVAL="$toolchains_dir/$_toolchain"
}

is_toolchain_installed() {
    _toolchain="$1"
    assert_nz "$_toolchain" "toolchain"

    verbose_say "looking for installed toolchain '$_toolchain'"

    get_toolchain_dir "$_toolchain"
    _toolchain_dir="$RETVAL"
    assert_nz "$_toolchain_dir" "toolchain dir"

    if [ -e "$_toolchain_dir" ]; then
	RETVAL=true
	return
    fi

    RETVAL=false
}

install_toolchain() {
    _toolchain="$1"
    assert_nz "$_toolchain" "toolchain"

    determine_remote_rust_installer_location "$_toolchain"
    _remote_rust_installer="$RETVAL"
    assert_nz "$_remote_rust_installer" "remote rust installer"
    verbose_say "remote rust installer location: $_remote_rust_installer"

    determine_remote_cargo_installer_location "$_toolchain"
    _remote_cargo_installer="$RETVAL"
    assert_nz "$_remote_cargo_installer" "remote cargo installer"
    verbose_say "remote cargo installer location: $_remote_cargo_installer"

    verbose_say "creating toolchains dir '$toolchains_dir'"
    mkdir -p "$toolchains_dir"
    need_ok "failed to make toolchain dir"

    # Create a temp directory to put the downloaded toolchain
    verbose_say "creating temp dir: '$_temp_dir'"
    mkdir -p "$temp_dir"
    need_ok "couldn't make temp dir"
    _workdir=$(make_temp_dir)
    assert_nz "$_workdir" "workdir"
    verbose_say "download work dir: $_workdir"

    # Download the toolchain
    say "downloading rust installer from '$_remote_rust_installer'"
    (cd "$_workdir" && curl -f -O "$_remote_rust_installer")
    if [ $? != 0 ]; then
	rm -R "$_workdir"
	err "failed to download rust installer"
    fi
    say "downloading cargo installer from '$_remote_cargo_installer'"
    (cd "$_workdir" && curl -f -O "$_remote_cargo_installer")
    if [ $? != 0 ]; then
	rm -R "$_workdir"
	err "failed to download cargo installer"
    fi

    _rust_installer_name=$(basename "$_remote_rust_installer")
    assert_nz "$_rust_installer_name" "rust installer name"
    _cargo_installer_name=$(basename "$_remote_cargo_installer")
    assert_nz "$_cargo_installer_name" "cargo installer name"
    _rust_installer_dir=$(echo "$_rust_installer_name" | sed s/.tar.gz$//)
    assert_nz "$_rust_installer_dir" "rust installer dir"
    _cargo_installer_dir=$(echo "$_cargo_installer_name" | sed s/.tar.gz$//)
    assert_nz "$_cargo_installer_dir" "cargo installer dir"

    # Extract the toolchain
    (cd "$_workdir" && tar xzf "$_rust_installer_name")
    if [ $? != 0 ]; then
	rm -R "$_workdir"
	err "failed to extract rust installer"
    fi
    (cd "$_workdir" && tar xzf "$_cargo_installer_name")
    if [ $? != 0 ]; then
	rm -R "$_workdir"
	err "failed to extract cargo installer"
    fi

    # Install the toolchain
    get_toolchain_dir "$_toolchain"
    _toolchain_dir="$RETVAL"
    assert_nz "$_toolchain_dir" "toolchain dir"
    verbose_say "installing toolchain to '$_toolchain_dir'"
    say "installing toolchain for '$_toolchain'"

    mkdir -p "$_toolchain_dir"
    if [ $? != 0 ]; then
	rm -R "$_workdir"
	err "failed to create toolchain install dir"
    fi

    sh "$_workdir/$_rust_installer_dir/install.sh" --prefix="$_toolchain_dir"
    if [ $? != 0 ]; then
	rm -R "$_toolchain_dir"
	rm -R "$_workdir"
	err "failed to install toolchain"
    fi

    sh "$_workdir/$_cargo_installer_dir/install.sh" --prefix="$_toolchain_dir"
    if [ $? != 0 ]; then
	rm -R "$_toolchain_dir"
	rm -R "$_workdir"
	err "failed to install toolchain"
    fi
    
    rm -R "$_workdir"
}

install_toolchain_if_not_installed() {
    _toolchain="$1"
    assert_nz "$_toolchain" "toolchain"

    is_toolchain_installed "$_toolchain"
    if [ "$RETVAL" = true ]; then
	say "using existing install for '$_toolchain'"
	return 0
    else
	say "installing toolchain '$_toolchain'"
	install_toolchain "$_toolchain"
    fi
}

update_toolchain() {
    _toolchain="$1"
    assert_nz "$_toolchain" "toolchain"

    is_toolchain_installed "$_toolchain"
    if [ "$RETVAL" = true ]; then
	say "updating existing install for '$_toolchain'"
    else
	say "installing toolchain '$_toolchain'"
    fi

    install_toolchain "$_toolchain"
}

remove_toolchain() {
    _toolchain="$1"
    assert_nz "$_toolchain" "toolchain"

    _toolchain_dir="$toolchains_dir/$_toolchain"

    if [ -e "$_toolchain_dir" ]; then
	verbose_say "removing directory '$_toolchain_dir'"
	# Need to use -f because it contains Cargo's git directories
	rm -Rf "$_toolchain_dir"
	need_ok "failed to remove toolchain"
	say "toolchain '$_toolchain' uninstalled"
    else
	say "no toolchain installed for '$_toolchain'"
    fi
}

find_default_sysroot() {
    if [ ! -e "$default_file" ]; then
	err 'no default toolchain configured. run `multirust help default`'
    fi

    _default=$(cat "$default_file")
    assert_nz "_$default" "default file is empty"

    get_toolchain_dir "$_default"
    _sysroot="$RETVAL"
    assert_nz "$_sysroot" "sysroot"
    
    if [ ! -d "$_sysroot" ]; then
	err "installation for default toolchain '$_default' does not exist. while this is odd, try running \`multirust update $_default\` to repair"
    fi

    RETVAL="$_sysroot"
}

find_override() {
    if [ ! -e "$override_db" ]; then
	return 1
    fi

    _dir="$(pwd)"
    assert_nz "$_dir" "empty starting dir"

    # Go up the directory hierarchy looking for overrides
    while [ "$_dir" != "/" -a "$_dir" != "." ]; do
	while read _line; do
	    _ovrdir=$(echo "$_line" | cut -f1)
	    need_ok "extracting record from db failed"
	    assert_nz "$_ovrdir" "empty dir in override db"
	    _toolchain=$(echo "$_line" | cut -f2)
	    need_ok "extracting record from db failed"
	    assert_nz "$_toolchain" "empty toolchain in override db"

	    if [ "$_dir" = "$_ovrdir" ]; then
		RETVAL_OVRDIR="$_ovrdir"
		RETVAL_TOOLCHAIN="$_toolchain"
		get_toolchain_dir "$_toolchain"
		RETVAL_SYSROOT="$RETVAL"
		if [ ! -e "$RETVAL_SYSROOT" ]; then
		    err "installation for override toolchain '$_toolchain' does not exist. while this is odd, try running \`multirust update $_toolchain\` to repair"
		fi
		return
	    fi
	done < "$override_db"

	_dir="$(dirname $_dir)"
    done

    return 1
}

find_override_sysroot_or_default() {
    if [ ! -e "$override_db" ]; then
	find_default_sysroot
	return
    fi

    if find_override; then
	RETVAL="$RETVAL_SYSROOT"
	return
    fi

    find_default_sysroot
}

print_override_sysroot_or_default() {
    find_override_sysroot_or_default
    echo "$RETVAL"
}

set_default() {
    _toolchain="$1"
    assert_nz "$_toolchain" "toolchain"

    _workfile=$(make_temp)
    need_ok "couldn't create temp file"
    echo "$_toolchain" > "$_workfile"
    if [ $? != 0 ]; then
	rm -R "$_workfile"
	err "couldn't write default toolchain to tempfile"
    fi

    mv -f "$_workfile" "$default_file"
    if [ $? != 0 ]; then
	rm -R "$_workfile"
	err "couldn't set default toolchain"
    fi

    say "default toolchain set to '$_toolchain'"
}

set_override() {
    _toolchain="$1"
    assert_nz "$_toolchain" "toolchain"

    _override_dir="$(pwd)"
    assert_nz "$_override_dir" "empty pwd?"

    # Escape forward-slashes
    _escaped_override_dir=`echo "$_override_dir" | sed s/\\\//\\\\\\\\\\\//g`

    _workfile=$(make_temp)
    need_ok "failed to create temp file"

    # Copy the current db to a new file, removing any existing override
    if [ -e "$override_db" ]; then
	sed "/^$_escaped_override_dir\t/d" "$override_db" > "$_workfile"
	if [ $? != 0 ]; then
	    rm -R "$_workfile"
	    err "unable to edit override db"
	fi
    fi

    # Escape the tab
    _line=$(echo "$_override_dir\t$_toolchain" | awk /\t/)
    # Append the new override
    echo "$_line" >> "$_workfile"
    if [ $? != 0 ]; then
	rm -R "$_workfile"
	err "unable to edit override db"
    fi

    # Move it back to the database
    mv -f "$_workfile" "$override_db"
    need_ok "unable to edit override db"

    say "override toolchain for '$_override_dir' set to '$_toolchain'"
}

remove_override() {
    _override_dir="$(pwd)"
    assert_nz "$_override_dir" "empty pwd?"

    # Escape forward-slashes
    _escaped_override_dir=`echo "$_override_dir" | sed s/\\\//\\\\\\\\\\\//g`

    _workfile=$(make_temp)
    need_ok "failed to create temp file"

    # Check if the override exists
    _have_override=false
    if [ -e "$override_db" ]; then
	# Get an actual tab character because grep doesn't interpret \t
	_tab=$(echo '\t' | awk '/\t/')
	egrep "^$_escaped_override_dir$_tab" "$override_db" > /dev/null
	if [ $? = 0 ]; then
	    _have_override=true
	fi
    fi
    if [ $_have_override = false ]; then
	say "no override for current directory '$_override_dir'"
	return
    fi

    # Copy the current db to a new file, removing any existing override
    if [ -e "$override_db" ]; then
	sed "/^$_escaped_override_dir\t/d" "$override_db" > "$_workfile"
	if [ $? != 0 ]; then
	    rm -R "$_workfile"
	    err "unable to edit override db"
	fi
    fi

    # Move it back to the database
    mv -f "$_workfile" "$override_db"
    need_ok "unable to edit override db"

    say "override toolchain for '$_override_dir' removed"
}

push_toolchain_ldpath() {
    _toolchain="$1"
    assert_nz "$_toolchain" "toolchain"

    get_toolchain_dir "$_toolchain"
    _toolchain_dir="$RETVAL"
    _new_path="$_toolchain_dir/lib"

    OLD_LD_LIBRARY_PATH="$LD_LIBRARY_PATH"
    LD_LIBRARY_PATH="$_new_path:$LD_LIBRARY_PATH"
    export LD_LIBRARY_PATH

    OLD_DYLD_LIBRARY_PATH="$DYLD_LIBRARY_PATH"
    DYLD_LIBRARY_PATH="$_new_path:$DYLD_LIBRARY_PATH"
    export DYLD_LIBRARY_PATH
}

pop_toolchain_ldpath() {
    LD_LIBRARY_PATH="$OLD_LD_LIBRARY_PATH"
    export LD_LIBRARY_PATH
    DYLD_LIBRARY_PATH="$OLD_DYLD_LIBRARY_PATH"
    export DYLD_LIBRARY_PATH
}

show_default() {
    if [ ! -e "$default_file" ]; then
	say "no default toolchain"
	return
    fi

    _toolchain=$(cat "$default_file")
    say "default toolchain: $_toolchain"

    get_toolchain_dir "$_toolchain"
    _toolchain_dir="$RETVAL"

    say "default location: $_toolchain_dir"

    push_toolchain_ldpath "$_toolchain"

    echo

    "$_toolchain_dir/bin/rustc" --version
    "$_toolchain_dir/bin/cargo" --version

    pop_toolchain_ldpath
}

show_override() {
    if find_override; then
	_ovrdir="$RETVAL_OVRDIR"
	_toolchain="$RETVAL_TOOLCHAIN"
	_sysroot="$RETVAL_SYSROOT"

	say "override directory; $_ovrdir"
	say "override toolchain: $_toolchain"
	say "override location: $_sysroot"

	push_toolchain_ldpath "$_toolchain"

	echo

	"$_toolchain_dir/bin/rustc" --version
	"$_toolchain_dir/bin/cargo" --version

	pop_toolchain_ldpath
    else
	say "no override"
    fi
}

list_overrides() {
    if [ -e "$override_db" ]; then
	_overrides=$(cat "$override_db" | sort)
	if [ -n "$_overrides" ]; then
	    echo "$_overrides"
	else
	    say "no overrides"
	fi
    else
	say "no overrides"
    fi
}

list_toolchains() {
    if [ -e "$toolchains_dir" ]; then
	_toolchains=$(cd "$toolchains_dir" && ls | sort)
	if [ -n "$_toolchains" ]; then
	    echo "$_toolchains"
	else
	    say "no installed toolchains"
	fi
    else
	say "no installed toolchains"
    fi
}

delete_data() {
    if [ ! "$flag_yes" = true ]; then
	read -p "This will delete all toolchains, overrides, aliases, and other multirust data associated with this user. Continue? (y/n) " yn

	case "$yn" in
	    [Nn] )
		exit 0
		;;
	esac
    fi

    # Need -f for Cargo's write-protected git directories
    rm -Rf "$multirust_dir"
    need_ok "failed to delete '$multirust_dir'"
}

# Check for some global options
for opt in "$@"; do
    case "$opt" in
	--verbose)
	    flag_verbose=true
	    ;;

	-y | --yes)
	    flag_yes=true
	    ;;

	--version)
	    echo "$version"
	    exit 0
	    ;;

    esac
done

cmd="$1"

# Make sure our data is in the correct format
check_metadata_version

case "$cmd" in
    default)
	if [ -z "$2" ]; then
	    err 'unspecified default toolchain. try `multirust help default`'
	fi
	install_toolchain_if_not_installed "$2"
	set_default "$2"
	;;

    override)
	if [ -z "$2" ]; then
	    err 'unspecified override toolchain. try `multirust help override`'
	fi
	install_toolchain_if_not_installed "$2"
	set_override "$2"
	;;

    alias)
	err "unimplemented"
	;;

    update)
	if [ -z "$2" ]; then
	    err 'unspecified update toolchain. try `multirust help update`'
	fi
	update_toolchain "$2"
	;;

    show-default)
	show_default
	;;

    show-override)
	show_override
	;;

    list-overrides)
	list_overrides
	;;

    list-toolchains)
	list_toolchains
	;;

    remove-override)
	remove_override
	;;

    remove-toolchain)
	if [ -z "$2" ]; then
	    err 'unspecified toolchain. try `multirust help remove-toolchain`'
	fi
	remove_toolchain "$2"
	;;

    remove-alias)
	err "unimplemented"
	;;

    delete-data)
	delete_data
	;;

    upgrade-data)
	err "unimplemented"
	;;

    gc)
	err "unimplemented"
	;;

    ctl)
	case "$2" in
	    override-sysroot)
		print_override_sysroot_or_default
		;;

	    "")
		err 'empty ctl command. try `multirust help ctl`'
		;;

	    *)
		err "unrecognized ctl comand \`$2\`. try \`multirust help ctl\`"
		;;
	esac
	;;

    help)
	case "$2" in
	    default)
		help_default
		;;
	    override)
		help_override
		;;
	    update)
		help_update
		;;
	    show-default)
		help_show_default
		;;
	    show-override)
		help_show_override
		;;
	    list-overrides)
		help_list_overrides
		;;
	    list-toolchains)
		help_list_toolchains
		;;
	    remove-override)
		help_remove_override
		;;
	    remove-toolchain)
		help_remove_toolchain
		;;
	    delete-data)
		help_delete_data
		;;
	    ctl)
		help_ctl
		;;
	    help)
		help
		;;
	    "") help
		;;
	    *)
		err "unrecognized command \`$2\`"
		;;
	esac
	;;

    *)
	help
	;;
esac

exit 0
